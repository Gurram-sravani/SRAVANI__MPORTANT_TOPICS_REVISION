class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        min_index=-1
        max_index=-1
        invalid_index=-1 # Keep track of invalid index [3,6,1,2,5,7,5] 
        no_of_subarrays=0
        for i in range(len(nums)):
            if nums[i]==minK:
                min_index=i
            if nums[i]==maxK:
                max_index=i
            if nums[i]<minK or nums[i]>maxK:
                invalid_index=i
            no_of_subarrays+=max(0,min(min_index,max_index)-invalid_index)
        return no_of_subarrays

# Time Complexity :O(n) 
# space Complexity:O(1) 

'''“I scan r from left to right, and at each r I count how many starting indices l are valid. I don’t explicitly move l; I compute how many ls work using bad, lastMin, and lastMax.”'''
  
  '''nums = [2, 1, 4, 1, 5], minK = 1, maxK = 5.

Initialize bad = -1, lastMin = -1, lastMax = -1, ans = 0.
Process each r:
r=0, val=2:
2 is in range [1,5], so bad unchanged.
not min or max → lastMin=-1, lastMax=-1.
min(lastMin,lastMax) = -1 → -1 - bad = -1 - (-1) = 0 → add 0. (no valid subarray ends at 0)

r=1, val=1:
in range. lastMin = 1.
min(lastMin,lastMax) = min(1,-1) = -1 → add 0.

r=2, val=4:
in range. no update to lastMin/lastMax.
min(1,-1) = -1 → add 0.

r=3, val=1:
in range. lastMin = 3.
min(3,-1) = -1 → add 0.

r=4, val=5:
in range. lastMax = 4.
min(lastMin,lastMax) = min(3,4) = 3.
add = 3 - bad = 3 - (-1) = 4.

That means there are 4 valid lefts: bad+1=0,1,2,3 → subarrays [0..4],[1..4],[2..4],[3..4]. Each contains at least one 1 and the 5, and no out-of-range. '''

Total ans = 4. (Matches enumerating valid subarrays ending at r=4.)''''
